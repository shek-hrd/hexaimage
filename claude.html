<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HexaImage Viewer Pro</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            font-size: 11px;
            background: #0a1a0a;
            color: #4ade80;
            overflow: hidden;
        }

        .container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        .header {
            background: #0f2715;
            padding: 8px 12px;
            border-bottom: 1px solid #22c55e;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
            font-size: 10px;
        }

        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
        }

        .file-input {
            position: absolute;
            left: -9999px;
        }

        .file-label {
            background: #166534;
            color: #dcfce7;
            padding: 4px 8px;
            cursor: pointer;
            border-radius: 2px;
            border: 1px solid #22c55e;
            font-size: 10px;
        }

        .file-label:hover {
            background: #22c55e;
            color: #0a1a0a;
        }

        .controls {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap;
        }

        select, button {
            background: #166534;
            color: #dcfce7;
            border: 1px solid #22c55e;
            padding: 3px 6px;
            font-size: 10px;
            cursor: pointer;
            border-radius: 2px;
        }

        button:hover, select:hover {
            background: #22c55e;
            color: #0a1a0a;
        }

        button:disabled {
            background: #064e3b;
            color: #166534;
            cursor: not-allowed;
        }

        .info {
            margin-left: auto;
            font-size: 9px;
            color: #86efac;
        }

        .viewer-container {
            flex: 1;
            display: flex;
            background: #0a1a0a;
        }

        .viewer-pane {
            flex: 1;
            position: relative;
            overflow: hidden;
            border-right: 1px solid #22c55e;
        }

        .viewer-pane:last-child {
            border-right: none;
        }

        .viewer-title {
            position: absolute;
            top: 4px;
            left: 8px;
            background: rgba(15, 39, 21, 0.9);
            padding: 2px 6px;
            border-radius: 2px;
            font-size: 9px;
            z-index: 10;
            border: 1px solid #22c55e;
        }

        .canvas-container {
            width: 100%;
            height: 100%;
            position: relative;
            overflow: hidden;
            cursor: grab;
        }

        .canvas-container:active {
            cursor: grabbing;
        }

        canvas {
            position: absolute;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }

        .grid-overlay {
            position: absolute;
            pointer-events: none;
            opacity: 0.3;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(15, 39, 21, 0.95);
            padding: 12px 20px;
            border-radius: 4px;
            border: 1px solid #22c55e;
            font-size: 11px;
        }

        .status-bar {
            background: #0f2715;
            padding: 4px 12px;
            border-top: 1px solid #22c55e;
            font-size: 9px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        @media (max-width: 768px) {
            .viewer-container {
                flex-direction: column;
            }
            
            .viewer-pane {
                border-right: none;
                border-bottom: 1px solid #22c55e;
            }
            
            .viewer-pane:last-child {
                border-bottom: none;
            }
            
            .header {
                font-size: 9px;
            }
            
            .controls {
                font-size: 9px;
            }
        }

        .status-info { color: #4ade80; }
        .status-warn { color: #fbbf24; }
        .status-error { color: #ef4444; }
        .status-debug { color: #8b5cf6; }
        .status-success { color: #10b981; }

        .debug-panel {
            position: fixed;
            top: 10px;
            right: 10px;
            width: 300px;
            max-height: 200px;
            background: rgba(15, 39, 21, 0.95);
            border: 1px solid #22c55e;
            border-radius: 4px;
            padding: 8px;
            font-size: 8px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
        }

        .debug-toggle {
            position: fixed;
            top: 10px;
            right: 320px;
            background: #166534;
            border: 1px solid #22c55e;
            color: #dcfce7;
            padding: 4px 8px;
            font-size: 9px;
            cursor: pointer;
            border-radius: 2px;
            z-index: 1001;
        }

        .performance-indicator {
            color: #86efac;
            font-size: 8px;
        }55e;
            color: #0a1a0a;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="file-input-wrapper">
                <input type="file" id="fileInput" class="file-input" accept="image/*,.raw,.rw2,.cr2,.nef,.orf,.dng,.arw,.pef,.x3f">
                <label for="fileInput" class="file-label">Load Image</label>
            </div>
            
            <div class="controls">
                <label>Algorithm:</label>
                <select id="algorithmSelect">
                    <option value="bilinear">Bilinear (Fast)</option>
                    <option value="nearest">Nearest (Performance)</option>
                    <option value="subpixel">Hexagonal Sub-pixel</option>
                </select>
                
                <button id="resetView">Reset View</button>
                <button id="toggleSync" class="active">Sync Views</button>
                <button id="toggleGrid">Grid: Off</button>
            </div>
            
            <div class="info">
                <span id="imageInfo">No image loaded</span>
            </div>
        </div>

        <div class="viewer-container">
            <div class="viewer-pane">
                <div class="viewer-title">Original (Orthogonal)</div>
                <div class="canvas-container" id="container1">
                    <canvas id="canvas1"></canvas>
                    <canvas class="grid-overlay" id="grid1"></canvas>
                </div>
            </div>
            
            <div class="viewer-pane">
                <div class="viewer-title">Hexagonal Projection</div>
                <div class="canvas-container" id="container2">
                    <canvas id="canvas2"></canvas>
                    <canvas class="grid-overlay" id="grid2"></canvas>
                </div>
            </div>
        </div>

        <div class="status-bar">
            <span id="statusText">Ready</span>
            <span id="zoomInfo">Zoom: 100%</span>
            <span class="performance-indicator" id="perfInfo"></span>
        </div>
    </div>

    <button class="debug-toggle" onclick="toggleDebugPanel()">Debug</button>
    <div class="debug-panel" id="debugPanel">
        <div style="font-weight: bold; margin-bottom: 4px;">Debug Console</div>
        <div id="debugLog"></div>
    </div>

    <script>
        // Debug logging system
        class DebugLogger {
            constructor() {
                this.logs = [];
                this.enableConsole = true;
            }
            
            log(level, message, data = null) {
                const timestamp = new Date().toISOString();
                const logEntry = { timestamp, level, message, data };
                this.logs.push(logEntry);
                
                if (this.enableConsole) {
                    const style = this.getLogStyle(level);
                    console.log(`%c[${level}] ${timestamp} - ${message}`, style, data || '');
                }
                
                this.updateStatusBar(level, message);
            }
            
            getLogStyle(level) {
                const styles = {
                    INFO: 'color: #4ade80; font-weight: bold;',
                    WARN: 'color: #fbbf24; font-weight: bold;',
                    ERROR: 'color: #ef4444; font-weight: bold;',
                    DEBUG: 'color: #8b5cf6; font-weight: normal;',
                    SUCCESS: 'color: #10b981; font-weight: bold;'
                };
                return styles[level] || styles.INFO;
            }
            
            updateStatusBar(level, message) {
                const statusEl = document.getElementById('statusText');
                if (statusEl) {
                    statusEl.textContent = `${message}`;
                    statusEl.className = `status-${level.toLowerCase()}`;
                }
                
                // Update debug panel
                this.updateDebugPanel();
            }
            
            updateDebugPanel() {
                const debugLog = document.getElementById('debugLog');
                if (debugLog) {
                    const recentLogs = this.logs.slice(-20); // Show last 20 logs
                    debugLog.innerHTML = recentLogs.map(log => 
                        `<div style="color: ${this.getLogColor(log.level)}; margin: 1px 0;">
                            [${log.level}] ${log.timestamp.split('T')[1].split('.')[0]} - ${log.message}
                        </div>`
                    ).join('');
                    debugLog.scrollTop = debugLog.scrollHeight;
                }
            }
            
            getLogColor(level) {
                const colors = {
                    INFO: '#4ade80',
                    WARN: '#fbbf24', 
                    ERROR: '#ef4444',
                    DEBUG: '#8b5cf6',
                    SUCCESS: '#10b981'
                };
                return colors[level] || '#4ade80';
            }
            
            exportLogs() {
                return JSON.stringify(this.logs, null, 2);
            }
        }

        // RAW file processor with detailed TIFF/RW2 parsing
        class RawProcessor {
            constructor(logger) {
                this.logger = logger;
                this.supportedFormats = {
                    'rw2': this.processRW2.bind(this),
                    'cr2': this.processCR2.bind(this),
                    'nef': this.processNEF.bind(this),
                    'orf': this.processORF.bind(this),
                    'dng': this.processDNG.bind(this),
                    'arw': this.processARW.bind(this),
                    'pef': this.processPEF.bind(this),
                    'x3f': this.processX3F.bind(this)
                };
            }
            
            async processRawFile(file) {
                const extension = file.name.split('.').pop().toLowerCase();
                this.logger.log('INFO', `Processing RAW file: ${file.name} (${extension})`);
                
                const arrayBuffer = await file.arrayBuffer();
                const dataView = new DataView(arrayBuffer);
                const uint8Array = new Uint8Array(arrayBuffer);
                
                this.logger.log('DEBUG', `File size: ${arrayBuffer.byteLength} bytes`);
                
                if (this.supportedFormats[extension]) {
                    return await this.supportedFormats[extension](dataView, uint8Array, file);
                } else {
                    throw new Error(`Unsupported RAW format: ${extension}`);
                }
            }
            
            async processRW2(dataView, uint8Array, file) {
                this.logger.log('INFO', 'Processing Panasonic RW2 file');
                
                // RW2 is based on TIFF format
                const tiffHeader = this.parseTiffHeader(dataView);
                this.logger.log('DEBUG', 'TIFF Header', tiffHeader);
                
                if (!tiffHeader) {
                    throw new Error('Invalid TIFF/RW2 header');
                }
                
                // Parse IFD (Image File Directory)
                const ifd = this.parseIFD(dataView, tiffHeader.ifdOffset, tiffHeader.littleEndian);
                this.logger.log('DEBUG', 'IFD entries', ifd);
                
                // Look for RAW data and thumbnails
                const rawData = await this.extractRW2Data(dataView, uint8Array, ifd, tiffHeader);
                
                if (rawData.fullResImage) {
                    this.logger.log('SUCCESS', `Extracted full resolution RAW data: ${rawData.width}x${rawData.height}`);
                    return rawData.fullResImage;
                } else if (rawData.preview) {
                    this.logger.log('WARN', 'Using preview image (full RAW processing not available)');
                    return rawData.preview;
                } else {
                    throw new Error('No usable image data found in RW2 file');
                }
            }
            
            parseTiffHeader(dataView) {
                try {
                    // Check byte order
                    const byteOrder = dataView.getUint16(0, false);
                    let littleEndian;
                    
                    if (byteOrder === 0x4949) { // "II"
                        littleEndian = true;
                        this.logger.log('DEBUG', 'TIFF byte order: Little Endian');
                    } else if (byteOrder === 0x4D4D) { // "MM"
                        littleEndian = false;
                        this.logger.log('DEBUG', 'TIFF byte order: Big Endian');
                    } else {
                        this.logger.log('ERROR', `Invalid TIFF magic number: 0x${byteOrder.toString(16)}`);
                        return null;
                    }
                    
                    // Check TIFF magic number (42)
                    const magic = dataView.getUint16(2, littleEndian);
                    if (magic !== 42) {
                        this.logger.log('ERROR', `Invalid TIFF magic: ${magic}, expected 42`);
                        return null;
                    }
                    
                    // Get IFD offset
                    const ifdOffset = dataView.getUint32(4, littleEndian);
                    this.logger.log('DEBUG', `IFD offset: 0x${ifdOffset.toString(16)}`);
                    
                    return { littleEndian, ifdOffset };
                } catch (error) {
                    this.logger.log('ERROR', 'Failed to parse TIFF header', error);
                    return null;
                }
            }
            
            parseIFD(dataView, offset, littleEndian) {
                try {
                    const entryCount = dataView.getUint16(offset, littleEndian);
                    this.logger.log('DEBUG', `IFD entries count: ${entryCount}`);
                    
                    const entries = {};
                    
                    for (let i = 0; i < entryCount; i++) {
                        const entryOffset = offset + 2 + (i * 12);
                        const tag = dataView.getUint16(entryOffset, littleEndian);
                        const type = dataView.getUint16(entryOffset + 2, littleEndian);
                        const count = dataView.getUint32(entryOffset + 4, littleEndian);
                        const valueOffset = dataView.getUint32(entryOffset + 8, littleEndian);
                        
                        entries[tag] = {
                            tag: tag,
                            type: type,
                            count: count,
                            valueOffset: valueOffset,
                            name: this.getTiffTagName(tag)
                        };
                        
                        this.logger.log('DEBUG', `Tag 0x${tag.toString(16)} (${entries[tag].name}): type=${type}, count=${count}, offset=0x${valueOffset.toString(16)}`);
                    }
                    
                    return entries;
                } catch (error) {
                    this.logger.log('ERROR', 'Failed to parse IFD', error);
                    return {};
                }
            }
            
            getTiffTagName(tag) {
                const tagNames = {
                    0x0100: 'ImageWidth',
                    0x0101: 'ImageLength',
                    0x0102: 'BitsPerSample',
                    0x0103: 'Compression',
                    0x0106: 'PhotometricInterpretation',
                    0x010E: 'ImageDescription',
                    0x010F: 'Make',
                    0x0110: 'Model',
                    0x0111: 'StripOffsets',
                    0x0112: 'Orientation',
                    0x0115: 'SamplesPerPixel',
                    0x0116: 'RowsPerStrip',
                    0x0117: 'StripByteCounts',
                    0x011A: 'XResolution',
                    0x011B: 'YResolution',
                    0x011C: 'PlanarConfiguration',
                    0x0128: 'ResolutionUnit',
                    0x0132: 'DateTime',
                    0x013B: 'Artist',
                    0x013E: 'WhitePoint',
                    0x013F: 'PrimaryChromaticities',
                    0x0201: 'JPEGInterchangeFormat',
                    0x0202: 'JPEGInterchangeFormatLength',
                    0x8769: 'ExifIFD',
                    0x8825: 'GPSIFD'
                };
                return tagNames[tag] || `Unknown_0x${tag.toString(16)}`;
            }
            
            async extractRW2Data(dataView, uint8Array, ifd, tiffHeader) {
                const results = {
                    width: null,
                    height: null,
                    fullResImage: null,
                    preview: null
                };
                
                // Get image dimensions
                if (ifd[0x0100]) { // ImageWidth
                    results.width = this.readTiffValue(dataView, ifd[0x0100], tiffHeader.littleEndian);
                    this.logger.log('DEBUG', `Image width: ${results.width}`);
                }
                
                if (ifd[0x0101]) { // ImageLength
                    results.height = this.readTiffValue(dataView, ifd[0x0101], tiffHeader.littleEndian);
                    this.logger.log('DEBUG', `Image height: ${results.height}`);
                }
                
                // Look for JPEG preview
                if (ifd[0x0201] && ifd[0x0202]) { // JPEGInterchangeFormat and Length
                    const jpegOffset = this.readTiffValue(dataView, ifd[0x0201], tiffHeader.littleEndian);
                    const jpegLength = this.readTiffValue(dataView, ifd[0x0202], tiffHeader.littleEndian);
                    
                    this.logger.log('DEBUG', `JPEG preview found: offset=0x${jpegOffset.toString(16)}, length=${jpegLength}`);
                    
                    try {
                        const jpegData = uint8Array.slice(jpegOffset, jpegOffset + jpegLength);
                        const blob = new Blob([jpegData], { type: 'image/jpeg' });
                        const url = URL.createObjectURL(blob);
                        
                        const img = await this.loadImageFromUrl(url);
                        results.preview = img;
                        this.logger.log('SUCCESS', `JPEG preview loaded: ${img.width}x${img.height}`);
                        
                        URL.revokeObjectURL(url);
                    } catch (error) {
                        this.logger.log('ERROR', 'Failed to load JPEG preview', error);
                    }
                }
                
                // Attempt to process RAW sensor data
                if (ifd[0x0111] && ifd[0x0117]) { // StripOffsets and StripByteCounts
                    this.logger.log('INFO', 'Attempting to process RAW sensor data...');
                    
                    try {
                        const rawImage = await this.processRawSensorData(dataView, uint8Array, ifd, tiffHeader, results);
                        if (rawImage) {
                            results.fullResImage = rawImage;
                            this.logger.log('SUCCESS', 'RAW sensor data processed successfully');
                        }
                    } catch (error) {
                        this.logger.log('WARN', 'RAW sensor processing failed', error);
                    }
                }
                
                return results;
            }
            
            async processRawSensorData(dataView, uint8Array, ifd, tiffHeader, imageInfo) {
                // This is a simplified RAW processor
                // In production, you'd need proper demosaicing, white balance, etc.
                
                const stripOffsets = this.readTiffValue(dataView, ifd[0x0111], tiffHeader.littleEndian);
                const stripByteCounts = this.readTiffValue(dataView, ifd[0x0117], tiffHeader.littleEndian);
                
                this.logger.log('DEBUG', `Strip offsets: ${stripOffsets}, byte counts: ${stripByteCounts}`);
                
                if (!imageInfo.width || !imageInfo.height) {
                    throw new Error('Missing image dimensions for RAW processing');
                }
                
                // Create canvas for RAW processing
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = imageInfo.width;
                canvas.height = imageInfo.height;
                
                // Simple demosaicing (this is very basic - production would use proper algorithms)
                const imageData = ctx.createImageData(imageInfo.width, imageInfo.height);
                
                try {
                    // Read RAW sensor data
                    const rawData = uint8Array.slice(stripOffsets, stripOffsets + stripByteCounts);
                    
                    // Apply basic demosaicing (simplified Bayer pattern processing)
                    for (let y = 0; y < imageInfo.height && y * imageInfo.width * 2 < rawData.length; y++) {
                        for (let x = 0; x < imageInfo.width && (y * imageInfo.width + x) * 2 < rawData.length; x++) {
                            const pixelIndex = (y * imageInfo.width + x) * 4;
                            const rawIndex = (y * imageInfo.width + x) * 2;
                            
                            if (rawIndex + 1 < rawData.length) {
                                // Read 16-bit RAW value and convert to 8-bit
                                const rawValue = (rawData[rawIndex] << 8) | rawData[rawIndex + 1];
                                const normalized = Math.min(255, Math.floor(rawValue / 256));
                                
                                // Simple Bayer pattern demosaicing
                                if ((x + y) % 2 === 0) {
                                    // Green pixels
                                    imageData.data[pixelIndex] = normalized * 0.3; // R
                                    imageData.data[pixelIndex + 1] = normalized; // G
                                    imageData.data[pixelIndex + 2] = normalized * 0.3; // B
                                } else if (x % 2 === 0) {
                                    // Blue pixels
                                    imageData.data[pixelIndex] = normalized * 0.2; // R
                                    imageData.data[pixelIndex + 1] = normalized * 0.7; // G
                                    imageData.data[pixelIndex + 2] = normalized; // B
                                } else {
                                    // Red pixels
                                    imageData.data[pixelIndex] = normalized; // R
                                    imageData.data[pixelIndex + 1] = normalized * 0.7; // G
                                    imageData.data[pixelIndex + 2] = normalized * 0.2; // B
                                }
                                imageData.data[pixelIndex + 3] = 255; // Alpha
                            }
                        }
                    }
                    
                    ctx.putImageData(imageData, 0, 0);
                    
                    // Convert canvas to image
                    const dataUrl = canvas.toDataURL();
                    const img = await this.loadImageFromUrl(dataUrl);
                    
                    return img;
                    
                } catch (error) {
                    this.logger.log('ERROR', 'RAW demosaicing failed', error);
                    throw error;
                }
            }
            
            readTiffValue(dataView, entry, littleEndian) {
                // Simplified TIFF value reader
                if (entry.count === 1) {
                    switch (entry.type) {
                        case 3: // SHORT
                            return entry.valueOffset & 0xFFFF;
                        case 4: // LONG
                            return entry.valueOffset;
                        default:
                            return entry.valueOffset;
                    }
                } else {
                    // For multiple values, read from the offset
                    return dataView.getUint32(entry.valueOffset, littleEndian);
                }
            }
            
            loadImageFromUrl(url) {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.onload = () => resolve(img);
                    img.onerror = reject;
                    img.src = url;
                });
            }
            
            // Placeholder processors for other RAW formats
            async processCR2(dataView, uint8Array, file) {
                this.logger.log('WARN', 'CR2 processing not fully implemented, attempting JPEG extraction');
                return this.extractEmbeddedJpeg(uint8Array);
            }
            
            async processNEF(dataView, uint8Array, file) {
                this.logger.log('WARN', 'NEF processing not fully implemented, attempting JPEG extraction');
                return this.extractEmbeddedJpeg(uint8Array);
            }
            
            async processORF(dataView, uint8Array, file) {
                this.logger.log('WARN', 'ORF processing not fully implemented, attempting JPEG extraction');
                return this.extractEmbeddedJpeg(uint8Array);
            }
            
            async processDNG(dataView, uint8Array, file) {
                this.logger.log('WARN', 'DNG processing not fully implemented, attempting JPEG extraction');
                return this.extractEmbeddedJpeg(uint8Array);
            }
            
            async processARW(dataView, uint8Array, file) {
                this.logger.log('WARN', 'ARW processing not fully implemented, attempting JPEG extraction');
                return this.extractEmbeddedJpeg(uint8Array);
            }
            
            async processPEF(dataView, uint8Array, file) {
                this.logger.log('WARN', 'PEF processing not fully implemented, attempting JPEG extraction');
                return this.extractEmbeddedJpeg(uint8Array);
            }
            
            async processX3F(dataView, uint8Array, file) {
                this.logger.log('WARN', 'X3F processing not fully implemented, attempting JPEG extraction');
                return this.extractEmbeddedJpeg(uint8Array);
            }
            
            async extractEmbeddedJpeg(uint8Array) {
                const jpegStart = this.findJpegMarker(uint8Array, 0xFF, 0xD8);
                if (jpegStart !== -1) {
                    const jpegEnd = this.findJpegMarker(uint8Array, 0xFF, 0xD9, jpegStart);
                    if (jpegEnd !== -1) {
                        const jpegData = uint8Array.slice(jpegStart, jpegEnd + 2);
                        const blob = new Blob([jpegData], { type: 'image/jpeg' });
                        const url = URL.createObjectURL(blob);
                        
                        try {
                            const img = await this.loadImageFromUrl(url);
                            URL.revokeObjectURL(url);
                            return img;
                        } catch (error) {
                            URL.revokeObjectURL(url);
                            throw error;
                        }
                    }
                }
                throw new Error('No embedded JPEG found');
            }
            
            findJpegMarker(data, byte1, byte2, startPos = 0) {
                for (let i = startPos; i < data.length - 1; i++) {
                    if (data[i] === byte1 && data[i + 1] === byte2) {
                        return i;
                    }
                }
                return -1;
            }
        }

        class HexagonalImageViewer {
            constructor() {
                this.logger = new DebugLogger();
                this.rawProcessor = new RawProcessor(this.logger);
                this.canvas1 = document.getElementById('canvas1');
                this.canvas2 = document.getElementById('canvas2');
                this.ctx1 = this.canvas1.getContext('2d');
                this.ctx2 = this.canvas2.getContext('2d');
                this.grid1 = document.getElementById('grid1');
                this.grid2 = document.getElementById('grid2');
                this.gridCtx1 = this.grid1.getContext('2d');
                this.gridCtx2 = this.grid2.getContext('2d');
                
                this.container1 = document.getElementById('container1');
                this.container2 = document.getElementById('container2');
                
                this.originalImage = null;
                this.imageData = null;
                this.hexImageData = null;
                
                this.zoom = 1;
                this.maxZoom = 32;
                this.minZoom = 0.1;
                this.pan = { x: 0, y: 0 };
                
                this.syncViews = true;
                this.showGrid = false;
                this.algorithm = 'bilinear';
                
                this.isDragging = false;
                this.lastMouse = { x: 0, y: 0 };
                
                this.setupEventListeners();
                this.setupUI();
                this.resizeCanvases();
            }
            
            setupEventListeners() {
                document.getElementById('fileInput').addEventListener('change', (e) => {
                    this.loadImage(e.target.files[0]);
                });
                
                document.getElementById('algorithmSelect').addEventListener('change', (e) => {
                    this.algorithm = e.target.value;
                    document.getElementById('statusText').textContent = `Switching to ${e.target.options[e.target.selectedIndex].text}...`;
                    
                    // Use setTimeout to allow UI to update before processing
                    setTimeout(() => {
                        this.processImage();
                    }, 10);
                });
                
                document.getElementById('resetView').addEventListener('click', () => {
                    this.resetView();
                });
                
                document.getElementById('toggleSync').addEventListener('click', (e) => {
                    this.syncViews = !this.syncViews;
                    e.target.textContent = this.syncViews ? 'Sync: On' : 'Sync: Off';
                    e.target.style.background = this.syncViews ? '#22c55e' : '#166534';
                    e.target.style.color = this.syncViews ? '#0a1a0a' : '#dcfce7';
                });
                
                document.getElementById('toggleGrid').addEventListener('click', (e) => {
                    this.showGrid = !this.showGrid;
                    e.target.textContent = this.showGrid ? 'Grid: On' : 'Grid: Off';
                    this.updateDisplay();
                });
                
                // Mouse events for both containers
                [this.container1, this.container2].forEach((container, index) => {
                    this.setupMouseEvents(container, index);
                });
                
                window.addEventListener('resize', () => {
                    this.resizeCanvases();
                    this.updateDisplay();
                });
            }
            
            setupMouseEvents(container, index) {
                container.addEventListener('mousedown', (e) => {
                    this.isDragging = true;
                    this.lastMouse = { x: e.clientX, y: e.clientY };
                    e.preventDefault();
                });
                
                container.addEventListener('mousemove', (e) => {
                    if (this.isDragging) {
                        const deltaX = e.clientX - this.lastMouse.x;
                        const deltaY = e.clientY - this.lastMouse.y;
                        
                        this.pan.x += deltaX / this.zoom;
                        this.pan.y += deltaY / this.zoom;
                        
                        this.lastMouse = { x: e.clientX, y: e.clientY };
                        this.updateDisplay();
                    }
                });
                
                container.addEventListener('mouseup', () => {
                    this.isDragging = false;
                });
                
                container.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    
                    const rect = container.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;
                    
                    const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                    const newZoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.zoom * zoomFactor));
                    
                    if (newZoom !== this.zoom) {
                        const zoomRatio = newZoom / this.zoom;
                        this.pan.x = mouseX + (this.pan.x - mouseX) * zoomRatio;
                        this.pan.y = mouseY + (this.pan.y - mouseY) * zoomRatio;
                        this.zoom = newZoom;
                        
                        this.updateDisplay();
                        document.getElementById('zoomInfo').textContent = `Zoom: ${Math.round(this.zoom * 100)}%`;
                    }
                });
            }
            
            setupUI() {
                // Additional UI setup if needed
            }
            
            async loadImage(file) {
                if (!file) return;
                
                document.getElementById('statusText').textContent = 'Loading image...';
                
                try {
                    // Check if it's a RAW format
                    const fileName = file.name.toLowerCase();
                    const rawFormats = ['.rw2', '.cr2', '.nef', '.orf', '.dng', '.arw', '.pef', '.x3f', '.raw'];
                    const isRaw = rawFormats.some(ext => fileName.endsWith(ext));
                    
                    if (isRaw) {
                        await this.loadRawImage(file);
                    } else {
                        await this.loadStandardImage(file);
                    }
                    
                } catch (error) {
                    console.error('Error loading image:', error);
                    document.getElementById('statusText').textContent = 'Error loading image: ' + error.message;
                }
            }
            
            async loadRawImage(file) {
                this.logger.log('INFO', `Starting RAW processing for: ${file.name}`);
                
                try {
                    const img = await this.rawProcessor.processRawFile(file);
                    
                    this.originalImage = img;
                    this.extractImageData();
                    this.resetView();
                    this.processImage();
                    
                    document.getElementById('imageInfo').textContent = 
                        `${img.naturalWidth}×${img.naturalHeight} | ${(file.size / 1024 / 1024).toFixed(2)}MB (RAW processed)`;
                    
                    this.logger.log('SUCCESS', 'RAW image processing completed successfully');
                    
                } catch (error) {
                    this.logger.log('ERROR', 'RAW processing failed', error);
                    throw error;
                }
            }
            
            findJpegInRaw(data) {
                // Look for JPEG SOI marker (0xFF 0xD8)
                for (let i = 0; i < data.length - 1; i++) {
                    if (data[i] === 0xFF && data[i + 1] === 0xD8) {
                        return i;
                    }
                }
                return -1;
            }
            
            findJpegEnd(data, start) {
                // Look for JPEG EOI marker (0xFF 0xD9)
                for (let i = start + 2; i < data.length - 1; i++) {
                    if (data[i] === 0xFF && data[i + 1] === 0xD9) {
                        return i + 2;
                    }
                }
                return -1;
            }
            
            async loadStandardImage(file) {
                const url = URL.createObjectURL(file);
                const img = new Image();
                
                return new Promise((resolve, reject) => {
                    img.onload = () => {
                        this.originalImage = img;
                        this.extractImageData();
                        this.resetView();
                        this.processImage();
                        
                        document.getElementById('imageInfo').textContent = 
                            `${img.naturalWidth}×${img.naturalHeight} | ${(file.size / 1024 / 1024).toFixed(2)}MB`;
                        document.getElementById('statusText').textContent = 'Image loaded successfully';
                        
                        URL.revokeObjectURL(url);
                        resolve();
                    };
                    
                    img.onerror = () => {
                        document.getElementById('statusText').textContent = 'Failed to load image';
                        URL.revokeObjectURL(url);
                        reject(new Error('Failed to load image'));
                    };
                    
                    img.src = url;
                });
            }
            
            extractImageData() {
                if (!this.originalImage) return;
                
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                
                tempCanvas.width = this.originalImage.naturalWidth;
                tempCanvas.height = this.originalImage.naturalHeight;
                
                tempCtx.drawImage(this.originalImage, 0, 0);
                this.imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
            }
            
            processImage() {
                if (!this.imageData) return;
                
                document.getElementById('statusText').textContent = `Processing with ${document.getElementById('algorithmSelect').selectedOptions[0].text}...`;
                
                const startTime = performance.now();
                
                // Clear previous hex data
                this.hexImageData = null;
                
                // Force a display update to show processing state
                this.ctx2.clearRect(0, 0, this.canvas2.width, this.canvas2.height);
                
                // Use setTimeout to allow UI to update before heavy processing
                setTimeout(() => {
                    switch (this.algorithm) {
                        case 'nearest':
                            this.hexImageData = this.createHexImageNearest();
                            break;
                        case 'bilinear':
                            this.hexImageData = this.createHexImageBilinear();
                            break;
                        case 'subpixel':
                            this.hexImageData = this.createHexImageSubpixel();
                            break;
                    }
                    
                    const processingTime = performance.now() - startTime;
                    document.getElementById('perfInfo').textContent = `Processed in ${processingTime.toFixed(1)}ms`;
                    document.getElementById('statusText').textContent = 'Processing complete';
                    
                    this.updateDisplay();
                }, 10);
            }
            
            createHexImageNearest() {
                const width = this.imageData.width;
                const height = this.imageData.height;
                const hexData = new ImageData(width, height);
                
                const hexHeight = Math.sqrt(3) / 2;
                
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const hexCoords = this.cartesianToHex(x, y, hexHeight);
                        const cartCoords = this.hexToCartesian(hexCoords.q, hexCoords.r, hexHeight);
                        
                        const sourceX = Math.round(cartCoords.x);
                        const sourceY = Math.round(cartCoords.y);
                        
                        if (sourceX >= 0 && sourceX < width && sourceY >= 0 && sourceY < height) {
                            const sourceIndex = (sourceY * width + sourceX) * 4;
                            const targetIndex = (y * width + x) * 4;
                            
                            hexData.data[targetIndex] = this.imageData.data[sourceIndex];
                            hexData.data[targetIndex + 1] = this.imageData.data[sourceIndex + 1];
                            hexData.data[targetIndex + 2] = this.imageData.data[sourceIndex + 2];
                            hexData.data[targetIndex + 3] = this.imageData.data[sourceIndex + 3];
                        }
                    }
                }
                
                return hexData;
            }
            
            createHexImageBilinear() {
                const width = this.imageData.width;
                const height = this.imageData.height;
                const hexData = new ImageData(width, height);
                
                const hexHeight = Math.sqrt(3) / 2;
                
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const hexCoords = this.cartesianToHex(x, y, hexHeight);
                        const cartCoords = this.hexToCartesian(hexCoords.q, hexCoords.r, hexHeight);
                        
                        const color = this.sampleBilinear(cartCoords.x, cartCoords.y);
                        const targetIndex = (y * width + x) * 4;
                        
                        hexData.data[targetIndex] = color.r;
                        hexData.data[targetIndex + 1] = color.g;
                        hexData.data[targetIndex + 2] = color.b;
                        hexData.data[targetIndex + 3] = color.a;
                    }
                }
                
                return hexData;
            }
            
            createHexImageSubpixel() {
                const width = this.imageData.width;
                const height = this.imageData.height;
                const hexData = new ImageData(width, height);
                
                const hexRadius = 0.7; // Smaller hexagonal pixels
                const hexHeight = Math.sqrt(3) / 2;
                
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        // Create multiple sub-hexagonal samples
                        let totalR = 0, totalG = 0, totalB = 0, totalA = 0;
                        let sampleCount = 0;
                        
                        // Sample in a hexagonal pattern around the pixel
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                const sampleX = x + dx * hexRadius;
                                const sampleY = y + dy * hexRadius;
                                
                                const hexCoords = this.cartesianToHex(sampleX, sampleY, hexHeight);
                                const cartCoords = this.hexToCartesian(hexCoords.q, hexCoords.r, hexHeight);
                                
                                const color = this.sampleBilinear(cartCoords.x, cartCoords.y);
                                
                                // Weight based on distance from center
                                const weight = Math.max(0, 1 - Math.sqrt(dx * dx + dy * dy) / 2);
                                
                                totalR += color.r * weight;
                                totalG += color.g * weight;
                                totalB += color.b * weight;
                                totalA += color.a * weight;
                                sampleCount += weight;
                            }
                        }
                        
                        const targetIndex = (y * width + x) * 4;
                        
                        if (sampleCount > 0) {
                            hexData.data[targetIndex] = Math.round(totalR / sampleCount);
                            hexData.data[targetIndex + 1] = Math.round(totalG / sampleCount);
                            hexData.data[targetIndex + 2] = Math.round(totalB / sampleCount);
                            hexData.data[targetIndex + 3] = Math.round(totalA / sampleCount);
                        }
                    }
                }
                
                return hexData;
            }
            
            cartesianToHex(x, y, hexHeight) {
                const q = (2/3) * x;
                const r = (-1/3) * x + (Math.sqrt(3)/3) * y;
                return { q: Math.round(q), r: Math.round(r) };
            }
            
            hexToCartesian(q, r, hexHeight) {
                const x = (3/2) * q;
                const y = (Math.sqrt(3)/2) * q + Math.sqrt(3) * r;
                return { x, y };
            }
            
            sampleBilinear(x, y) {
                const width = this.imageData.width;
                const height = this.imageData.height;
                
                if (x < 0 || x >= width - 1 || y < 0 || y >= height - 1) {
                    return { r: 0, g: 0, b: 0, a: 0 };
                }
                
                const x0 = Math.floor(x);
                const y0 = Math.floor(y);
                const x1 = x0 + 1;
                const y1 = y0 + 1;
                
                const fx = x - x0;
                const fy = y - y0;
                
                const getPixel = (px, py) => {
                    const index = (py * width + px) * 4;
                    return {
                        r: this.imageData.data[index],
                        g: this.imageData.data[index + 1],
                        b: this.imageData.data[index + 2],
                        a: this.imageData.data[index + 3]
                    };
                };
                
                const c00 = getPixel(x0, y0);
                const c10 = getPixel(x1, y0);
                const c01 = getPixel(x0, y1);
                const c11 = getPixel(x1, y1);
                
                return {
                    r: Math.round(
                        c00.r * (1 - fx) * (1 - fy) +
                        c10.r * fx * (1 - fy) +
                        c01.r * (1 - fx) * fy +
                        c11.r * fx * fy
                    ),
                    g: Math.round(
                        c00.g * (1 - fx) * (1 - fy) +
                        c10.g * fx * (1 - fy) +
                        c01.g * (1 - fx) * fy +
                        c11.g * fx * fy
                    ),
                    b: Math.round(
                        c00.b * (1 - fx) * (1 - fy) +
                        c10.b * fx * (1 - fy) +
                        c01.b * (1 - fx) * fy +
                        c11.b * fx * fy
                    ),
                    a: Math.round(
                        c00.a * (1 - fx) * (1 - fy) +
                        c10.a * fx * (1 - fy) +
                        c01.a * (1 - fx) * fy +
                        c11.a * fx * fy
                    )
                };
            }
            
            resetView() {
                if (!this.originalImage) return;
                
                const containerWidth = this.container1.clientWidth;
                const containerHeight = this.container1.clientHeight;
                
                const imageAspect = this.originalImage.naturalWidth / this.originalImage.naturalHeight;
                const containerAspect = containerWidth / containerHeight;
                
                if (imageAspect > containerAspect) {
                    this.zoom = containerWidth / this.originalImage.naturalWidth;
                } else {
                    this.zoom = containerHeight / this.originalImage.naturalHeight;
                }
                
                this.pan.x = (containerWidth - this.originalImage.naturalWidth * this.zoom) / 2;
                this.pan.y = (containerHeight - this.originalImage.naturalHeight * this.zoom) / 2;
                
                this.updateDisplay();
                document.getElementById('zoomInfo').textContent = `Zoom: ${Math.round(this.zoom * 100)}%`;
            }
            
            updateDisplay() {
                if (!this.originalImage) return;
                
                // Clear canvases
                this.ctx1.clearRect(0, 0, this.canvas1.width, this.canvas1.height);
                this.ctx2.clearRect(0, 0, this.canvas2.width, this.canvas2.height);
                
                // Draw original image
                this.ctx1.save();
                this.ctx1.translate(this.pan.x, this.pan.y);
                this.ctx1.scale(this.zoom, this.zoom);
                this.ctx1.drawImage(this.originalImage, 0, 0);
                this.ctx1.restore();
                
                // Draw hexagonal image
                if (this.hexImageData) {
                    const tempCanvas = document.createElement('canvas');
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCanvas.width = this.hexImageData.width;
                    tempCanvas.height = this.hexImageData.height;
                    tempCtx.putImageData(this.hexImageData, 0, 0);
                    
                    this.ctx2.save();
                    this.ctx2.translate(this.pan.x, this.pan.y);
                    this.ctx2.scale(this.zoom, this.zoom);
                    this.ctx2.drawImage(tempCanvas, 0, 0);
                    this.ctx2.restore();
                }
                
                // Draw grids if enabled and at max zoom
                if (this.showGrid && this.zoom >= this.maxZoom * 0.8) {
                    this.drawGrids();
                }
            }
            
            drawGrids() {
                const gridSize = Math.max(8, this.zoom);
                
                // Clear grids
                this.gridCtx1.clearRect(0, 0, this.grid1.width, this.grid1.height);
                this.gridCtx2.clearRect(0, 0, this.grid2.width, this.grid2.height);
                
                // Orthogonal grid
                this.gridCtx1.strokeStyle = '#22c55e';
                this.gridCtx1.lineWidth = 0.5;
                
                for (let x = this.pan.x % gridSize; x < this.canvas1.width; x += gridSize) {
                    this.gridCtx1.beginPath();
                    this.gridCtx1.moveTo(x, 0);
                    this.gridCtx1.lineTo(x, this.canvas1.height);
                    this.gridCtx1.stroke();
                }
                
                for (let y = this.pan.y % gridSize; y < this.canvas1.height; y += gridSize) {
                    this.gridCtx1.beginPath();
                    this.gridCtx1.moveTo(0, y);
                    this.gridCtx1.lineTo(this.canvas1.width, y);
                    this.gridCtx1.stroke();
                }
                
                // Hexagonal grid
                this.gridCtx2.strokeStyle = '#22c55e';
                this.gridCtx2.lineWidth = 0.5;
                
                const hexRadius = gridSize / 2;
                const hexHeight = Math.sqrt(3) / 2 * hexRadius;
                
                for (let row = -2; row < this.canvas2.height / hexHeight + 2; row++) {
                    for (let col = -2; col < this.canvas2.width / (hexRadius * 1.5) + 2; col++) {
                        const x = this.pan.x + col * hexRadius * 1.5;
                        const y = this.pan.y + row * hexHeight * 2 + (col % 2) * hexHeight;
                        
                        this.drawHexagon(this.gridCtx2, x, y, hexRadius);
                    }
                }
            }
            
            drawHexagon(ctx, centerX, centerY, radius) {
                ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle = (Math.PI / 3) * i;
                    const x = centerX + radius * Math.cos(angle);
                    const y = centerY + radius * Math.sin(angle);
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.closePath();
                ctx.stroke();
            }
            
            resizeCanvases() {
                const containers = [this.container1, this.container2];
                const canvases = [this.canvas1, this.canvas2];
                const grids = [this.grid1, this.grid2];
                
                containers.forEach((container, index) => {
                    const rect = container.getBoundingClientRect();
                    const canvas = canvases[index];
                    const grid = grids[index];
                    
                    canvas.width = rect.width;
                    canvas.height = rect.height;
                    canvas.style.width = rect.width + 'px';
                    canvas.style.height = rect.height + 'px';
                    
                    grid.width = rect.width;
                    grid.height = rect.height;
                    grid.style.width = rect.width + 'px';
                    grid.style.height = rect.height + 'px';
                });
            }
        }
        
        // Initialize the viewer when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            const viewer = new HexagonalImageViewer();
            
            // Make viewer globally accessible for debugging
            window.hexViewer = viewer;
            window.exportLogs = () => {
                const logs = viewer.logger.exportLogs();
                const blob = new Blob([logs], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'hex-viewer-debug-log.json';
                a.click();
                URL.revokeObjectURL(url);
            };
        });
        
        function toggleDebugPanel() {
            const panel = document.getElementById('debugPanel');
            panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
        }
    </script>
</body>
</html>